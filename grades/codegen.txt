=====STUDENT TESTS=====
====Good Tests====
===[good00.bminor Input]===
/* Integer declarations */
a: integer;
main: function integer () = { return 128; }

===[good00.bminor Output]===
.data
.global a
a:
    .quad 0

.text
.global main
main:
pushq %rbp
movq %rsp, %rbp
subq $0, %rsp
pushq %rbx
pushq %r12
pushq %r13
pushq %r14
pushq %r15
# 128
movq $128, %rbx
movq %rbx, %rax
jmp .main_epilogue
.main_epilogue:
popq %r15
popq %r14
popq %r13
popq %r12
popq %rbx
movq %rbp, %rsp
popq %rbp
ret




return code: 128


===[good01.bminor Input]===
/* Integer declaration with value */
a: integer = 128;
main: function integer () = { return 0; }

===[good01.bminor Output]===
.data
.global a
a:
    .quad 128

.text
.global main
main:
pushq %rbp
movq %rsp, %rbp
subq $0, %rsp
pushq %rbx
pushq %r12
pushq %r13
pushq %r14
pushq %r15
# 0
movq $0, %rbx
movq %rbx, %rax
jmp .main_epilogue
.main_epilogue:
popq %r15
popq %r14
popq %r13
popq %r12
popq %rbx
movq %rbp, %rsp
popq %rbp
ret




return code: 0


===[good02.bminor Input]===
/* String declaration */
s: string;
main: function integer () = { return 128; }

===[good02.bminor Output]===
.data
.global s
s:
    .quad 0

.text
.global main
main:
pushq %rbp
movq %rsp, %rbp
subq $0, %rsp
pushq %rbx
pushq %r12
pushq %r13
pushq %r14
pushq %r15
# 128
movq $128, %rbx
movq %rbx, %rax
jmp .main_epilogue
.main_epilogue:
popq %r15
popq %r14
popq %r13
popq %r12
popq %rbx
movq %rbp, %rsp
popq %rbp
ret




return code: 128


===[good03.bminor Input]===
/* String declaration with value */
s1: string = "Hello World";
s2: string = "sam\n";
main: function integer () = { return 128; }

===[good03.bminor Output]===
.data
.global s1
s1:
    .string "Hello World"

.data
.global s2
s2:
    .string "sam\n"

.text
.global main
main:
pushq %rbp
movq %rsp, %rbp
subq $0, %rsp
pushq %rbx
pushq %r12
pushq %r13
pushq %r14
pushq %r15
# 128
movq $128, %rbx
movq %rbx, %rax
jmp .main_epilogue
.main_epilogue:
popq %r15
popq %r14
popq %r13
popq %r12
popq %rbx
movq %rbp, %rsp
popq %rbp
ret




return code: 128


===[good04.bminor Input]===
/* Function referencing global var */
a: integer = 128;
main: function integer () = {
    return a;
}

===[good04.bminor Output]===
.data
.global a
a:
    .quad 128

.text
.global main
main:
pushq %rbp
movq %rsp, %rbp
subq $0, %rsp
pushq %rbx
pushq %r12
pushq %r13
pushq %r14
pushq %r15
# a
movq a, %rbx
movq %rbx, %rax
jmp .main_epilogue
.main_epilogue:
popq %r15
popq %r14
popq %r13
popq %r12
popq %rbx
movq %rbp, %rsp
popq %rbp
ret




return code: 128


===[good05.bminor Input]===
/* Function referencing local var */
main: function integer () = {
    a: integer = 128;
    return a;
}

===[good05.bminor Output]===
.text
.global main
main:
pushq %rbp
movq %rsp, %rbp
subq $8, %rsp
pushq %rbx
pushq %r12
pushq %r13
pushq %r14
pushq %r15
# 128
movq $128, %rbx
movq %rbx, -8(%rbp)
# a
movq -8(%rbp), %rbx
movq %rbx, %rax
jmp .main_epilogue
.main_epilogue:
popq %r15
popq %r14
popq %r13
popq %r12
popq %rbx
movq %rbp, %rsp
popq %rbp
ret




return code: 128


===[good06.bminor Input]===
/* Arithmetics */
main: function integer () = {
    a: integer = 128;
    b: integer = 64;
    return (a / b) + 1; // 3
}

===[good06.bminor Output]===
.text
.global main
main:
pushq %rbp
movq %rsp, %rbp
subq $16, %rsp
pushq %rbx
pushq %r12
pushq %r13
pushq %r14
pushq %r15
# 128
movq $128, %rbx
movq %rbx, -8(%rbp)
# 64
movq $64, %rbx
movq %rbx, -16(%rbp)
# a
movq -8(%rbp), %rbx
# b
movq -16(%rbp), %r10
# a / b
movq %rbx, %rax
cqo
idivq %r10
movq %rax, %rbx
# 1
movq $1, %r10
# a / b + 1
addq %r10, %rbx
movq %rbx, %rax
jmp .main_epilogue
.main_epilogue:
popq %r15
popq %r14
popq %r13
popq %r12
popq %rbx
movq %rbp, %rsp
popq %rbp
ret




return code: 3


===[good07.bminor Input]===
/* Array declaration */
a: array [4] integer = {0, 1, 2, 3};
main: function integer () = { return 128; }

===[good07.bminor Output]===
.data
.global a
a:
        .quad 0
        .quad 1
        .quad 2
        .quad 3

.text
.global main
main:
pushq %rbp
movq %rsp, %rbp
subq $0, %rsp
pushq %rbx
pushq %r12
pushq %r13
pushq %r14
pushq %r15
# 128
movq $128, %rbx
movq %rbx, %rax
jmp .main_epilogue
.main_epilogue:
popq %r15
popq %r14
popq %r13
popq %r12
popq %rbx
movq %rbp, %rsp
popq %rbp
ret




return code: 128


===[good08.bminor Input]===
/* Indexing */
a: array [4] integer = {0, 1, 2, 3};
main: function integer () = {
    return a[0] + a[1] + a[2] + a[3]; // 6
}

===[good08.bminor Output]===
.data
.global a
a:
        .quad 0
        .quad 1
        .quad 2
        .quad 3

.text
.global main
main:
pushq %rbp
movq %rsp, %rbp
subq $0, %rsp
pushq %rbx
pushq %r12
pushq %r13
pushq %r14
pushq %r15
# a
leaq a, %rbx
# 0
movq $0, %r10
# a[0]
movq (%rbx, %r10, 8), %r11
# a
leaq a, %rbx
# 1
movq $1, %r10
# a[1]
movq (%rbx, %r10, 8), %r12
# a[0] + a[1]
addq %r12, %r11
# a
leaq a, %rbx
# 2
movq $2, %r10
# a[2]
movq (%rbx, %r10, 8), %r12
# a[0] + a[1] + a[2]
addq %r12, %r11
# a
leaq a, %rbx
# 3
movq $3, %r10
# a[3]
movq (%rbx, %r10, 8), %r12
# a[0] + a[1] + a[2] + a[3]
addq %r12, %r11
movq %r11, %rax
jmp .main_epilogue
.main_epilogue:
popq %r15
popq %r14
popq %r13
popq %r12
popq %rbx
movq %rbp, %rsp
popq %rbp
ret




return code: 6


===[good09.bminor Input]===
/* Indexing with expression */
a: array [4] integer = {0, 1, 2, 3};
main: function integer () = {
    return a[1 + 1 + 1]; // 3
}

===[good09.bminor Output]===
.data
.global a
a:
        .quad 0
        .quad 1
        .quad 2
        .quad 3

.text
.global main
main:
pushq %rbp
movq %rsp, %rbp
subq $0, %rsp
pushq %rbx
pushq %r12
pushq %r13
pushq %r14
pushq %r15
# a
leaq a, %rbx
# 1
movq $1, %r10
# 1
movq $1, %r11
# 1 + 1
addq %r11, %r10
# 1
movq $1, %r11
# 1 + 1 + 1
addq %r11, %r10
# a[1 + 1 + 1]
movq (%rbx, %r10, 8), %r11
movq %r11, %rax
jmp .main_epilogue
.main_epilogue:
popq %r15
popq %r14
popq %r13
popq %r12
popq %rbx
movq %rbp, %rsp
popq %rbp
ret




return code: 3


===[good10.bminor Input]===
/* Assign to global variable */
a: integer = 128;
main: function integer () = {
    a = a - 1;
    return a;
}

===[good10.bminor Output]===
.data
.global a
a:
    .quad 128

.text
.global main
main:
pushq %rbp
movq %rsp, %rbp
subq $0, %rsp
pushq %rbx
pushq %r12
pushq %r13
pushq %r14
pushq %r15
# a
movq a, %rbx
# a
movq a, %r10
# 1
movq $1, %r11
# a - 1
subq %r11, %r10
# a = a - 1
movq %r10, a
# a
movq a, %rbx
movq %rbx, %rax
jmp .main_epilogue
.main_epilogue:
popq %r15
popq %r14
popq %r13
popq %r12
popq %rbx
movq %rbp, %rsp
popq %rbp
ret




return code: 127


===[good11.bminor Input]===
/* Function call */
f: function integer () = {
    return 128;
}

main : function integer () = {
    return f();
}

===[good11.bminor Output]===
.text
.global f
f:
pushq %rbp
movq %rsp, %rbp
subq $0, %rsp
pushq %rbx
pushq %r12
pushq %r13
pushq %r14
pushq %r15
# 128
movq $128, %rbx
movq %rbx, %rax
jmp .f_epilogue
.f_epilogue:
popq %r15
popq %r14
popq %r13
popq %r12
popq %rbx
movq %rbp, %rsp
popq %rbp
ret

.text
.global main
main:
pushq %rbp
movq %rsp, %rbp
subq $0, %rsp
pushq %rbx
pushq %r12
pushq %r13
pushq %r14
pushq %r15
# f
# f()
pushq %r10
pushq %r11
call f
addq $0, %rsp
pushq %r11
pushq %r10
movq %rax, %r10
movq %r10, %rax
jmp .main_epilogue
.main_epilogue:
popq %r15
popq %r14
popq %r13
popq %r12
popq %rbx
movq %rbp, %rsp
popq %rbp
ret




return code: 128


===[good12.bminor Input]===
/* Function call with arg */
f: function integer (arg : integer) = {
    return arg;
}

main : function integer () = {
    return f(0);
}

===[good12.bminor Output]===
.text
.global f
f:
pushq %rbp
movq %rsp, %rbp
subq $0, %rsp
pushq %rbx
pushq %r12
pushq %r13
pushq %r14
pushq %r15
# arg
movq  8(%rbp), %rbx
movq %rbx, %rax
jmp .f_epilogue
.f_epilogue:
popq %r15
popq %r14
popq %r13
popq %r12
popq %rbx
movq %rbp, %rsp
popq %rbp
ret

.text
.global main
main:
pushq %rbp
movq %rsp, %rbp
subq $0, %rsp
pushq %rbx
pushq %r12
pushq %r13
pushq %r14
pushq %r15
# f
# f(0)
pushq %r10
pushq %r11
# 0
movq $0, %r11
# 0
pushq %r11
call f
addq $8, %rsp
pushq %r11
pushq %r10
movq %rax, %r10
movq %r10, %rax
jmp .main_epilogue
.main_epilogue:
popq %r15
popq %r14
popq %r13
popq %r12
popq %rbx
movq %rbp, %rsp
popq %rbp
ret




return code: 49


===[good13.bminor Input]===
/* Function call with args */
f: function integer (arg1 : integer, arg2 : integer) = {
    return arg1 + arg2;
}

main : function integer () = {
    return f(12, 24); // 36
}

===[good13.bminor Output]===
.text
.global f
f:
pushq %rbp
movq %rsp, %rbp
subq $0, %rsp
pushq %rbx
pushq %r12
pushq %r13
pushq %r14
pushq %r15
# arg1
movq  8(%rbp), %rbx
# arg2
movq  16(%rbp), %r10
# arg1 + arg2
addq %r10, %rbx
movq %rbx, %rax
jmp .f_epilogue
.f_epilogue:
popq %r15
popq %r14
popq %r13
popq %r12
popq %rbx
movq %rbp, %rsp
popq %rbp
ret

.text
.global main
main:
pushq %rbp
movq %rsp, %rbp
subq $0, %rsp
pushq %rbx
pushq %r12
pushq %r13
pushq %r14
pushq %r15
# f
# f(12, 24)
pushq %r10
pushq %r11
# 12
movq $12, %r11
# 24
movq $24, %r12
# 24
pushq %r12
# 12, 24
pushq %r11
call f
addq $16, %rsp
pushq %r11
pushq %r10
movq %rax, %r10
movq %r10, %rax
jmp .main_epilogue
.main_epilogue:
popq %r15
popq %r14
popq %r13
popq %r12
popq %rbx
movq %rbp, %rsp
popq %rbp
ret




return code: 77


===[good14.bminor Input]===
/* If-else */
main : function integer () = {
    cond: boolean = true;
    if (cond)
        return 128;
    else
        return 127;
}

===[good14.bminor Output]===
.text
.global main
main:
pushq %rbp
movq %rsp, %rbp
subq $8, %rsp
pushq %rbx
pushq %r12
pushq %r13
pushq %r14
pushq %r15
# true
movq $1, %rbx
movq %rbx, -8(%rbp)
# if-else condition
# cond
movq -8(%rbp), %rbx
cmp $0, %rbx
je .L1
# if-else body
# 128
movq $128, %rbx
movq %rbx, %rax
jmp .main_epilogue
jmp .L2
# if-else else body
.L1:
# 127
movq $127, %rbx
movq %rbx, %rax
jmp .main_epilogue
.L2:
.main_epilogue:
popq %r15
popq %r14
popq %r13
popq %r12
popq %rbx
movq %rbp, %rsp
popq %rbp
ret




return code: 128


===[good15.bminor Input]===
/* Integer declarations */
a: integer;
main: function integer () = { return 128; }

===[good15.bminor Output]===
.data
.global a
a:
    .quad 0

.text
.global main
main:
pushq %rbp
movq %rsp, %rbp
subq $0, %rsp
pushq %rbx
pushq %r12
pushq %r13
pushq %r14
pushq %r15
# 128
movq $128, %rbx
movq %rbx, %rax
jmp .main_epilogue
.main_epilogue:
popq %r15
popq %r14
popq %r13
popq %r12
popq %rbx
movq %rbp, %rsp
popq %rbp
ret




return code: 128


===[good16.bminor Input]===
/* Integer declaration with value */
a: integer = 128;
main: function integer () = { return 0; }

===[good16.bminor Output]===
.data
.global a
a:
    .quad 128

.text
.global main
main:
pushq %rbp
movq %rsp, %rbp
subq $0, %rsp
pushq %rbx
pushq %r12
pushq %r13
pushq %r14
pushq %r15
# 0
movq $0, %rbx
movq %rbx, %rax
jmp .main_epilogue
.main_epilogue:
popq %r15
popq %r14
popq %r13
popq %r12
popq %rbx
movq %rbp, %rsp
popq %rbp
ret




return code: 0


===[good17.bminor Input]===
/* String declaration */
s: string;
main: function integer () = { return 128; }

===[good17.bminor Output]===
.data
.global s
s:
    .quad 0

.text
.global main
main:
pushq %rbp
movq %rsp, %rbp
subq $0, %rsp
pushq %rbx
pushq %r12
pushq %r13
pushq %r14
pushq %r15
# 128
movq $128, %rbx
movq %rbx, %rax
jmp .main_epilogue
.main_epilogue:
popq %r15
popq %r14
popq %r13
popq %r12
popq %rbx
movq %rbp, %rsp
popq %rbp
ret




return code: 128


===[good18.bminor Input]===
/* String declaration with value */
s1: string = "Hello World";
s2: string = "sam\n";
main: function integer () = { return 128; }

===[good18.bminor Output]===
.data
.global s1
s1:
    .string "Hello World"

.data
.global s2
s2:
    .string "sam\n"

.text
.global main
main:
pushq %rbp
movq %rsp, %rbp
subq $0, %rsp
pushq %rbx
pushq %r12
pushq %r13
pushq %r14
pushq %r15
# 128
movq $128, %rbx
movq %rbx, %rax
jmp .main_epilogue
.main_epilogue:
popq %r15
popq %r14
popq %r13
popq %r12
popq %rbx
movq %rbp, %rsp
popq %rbp
ret




return code: 128


===[good19.bminor Input]===
/* Function referencing global var */
a: integer = 128;
main: function integer () = {
    return a;
}

===[good19.bminor Output]===
.data
.global a
a:
    .quad 128

.text
.global main
main:
pushq %rbp
movq %rsp, %rbp
subq $0, %rsp
pushq %rbx
pushq %r12
pushq %r13
pushq %r14
pushq %r15
# a
movq a, %rbx
movq %rbx, %rax
jmp .main_epilogue
.main_epilogue:
popq %r15
popq %r14
popq %r13
popq %r12
popq %rbx
movq %rbp, %rsp
popq %rbp
ret




return code: 128


====Bad Tests====
=====HIDDEN TESTS=====
====Good Tests====
===[good1.bminor Input]===
strlen: function integer(s: string);
f: function integer(i: integer);

main: function integer () = {
	if (f(strlen("hi")) > strlen("there")) {print "no\n";}
	if (f(f(strlen("hi"))) > strlen("there")) print "ok\n";

	return 0;
}

f: function integer(i: integer) = {
	return i*2;
}

===[good1.bminor Output]===
TEST NOT PASSED - CODEGEN ERROR



return code: 1


===[good11.bminor Input]===
main: function integer () = {
	x: integer = 20;
	y: integer = x;
	{
		x: integer = 10;
		y = y + x;
	}

	{
		{
			y = y + x;
			x: integer = 2;
			y = y + x;
		}
		y = y + x;
		x: integer = 3;
		y = y + x;
	}
	return y + x;
}

===[good11.bminor Output]===
.text
.global main
main:
pushq %rbp
movq %rsp, %rbp
subq $40, %rsp
pushq %rbx
pushq %r12
pushq %r13
pushq %r14
pushq %r15
# 20
movq $20, %rbx
movq %rbx, -8(%rbp)
# x
movq -8(%rbp), %rbx
movq %rbx, -16(%rbp)
# 10
movq $10, %rbx
movq %rbx, -24(%rbp)
# y
movq -16(%rbp), %rbx
# y
movq -16(%rbp), %r10
# x
movq -24(%rbp), %r11
# y + x
addq %r11, %r10
# y = y + x
movq %r10, -16(%rbp)
# y
movq -16(%rbp), %rbx
# y
movq -16(%rbp), %r10
# x
movq -8(%rbp), %r11
# y + x
addq %r11, %r10
# y = y + x
movq %r10, -16(%rbp)
# 2
movq $2, %rbx
movq %rbx, -32(%rbp)
# y
movq -16(%rbp), %rbx
# y
movq -16(%rbp), %r10
# x
movq -32(%rbp), %r11
# y + x
addq %r11, %r10
# y = y + x
movq %r10, -16(%rbp)
# y
movq -16(%rbp), %rbx
# y
movq -16(%rbp), %r10
# x
movq -8(%rbp), %r11
# y + x
addq %r11, %r10
# y = y + x
movq %r10, -16(%rbp)
# 3
movq $3, %rbx
movq %rbx, -40(%rbp)
# y
movq -16(%rbp), %rbx
# y
movq -16(%rbp), %r10
# x
movq -40(%rbp), %r11
# y + x
addq %r11, %r10
# y = y + x
movq %r10, -16(%rbp)
# y
movq -16(%rbp), %rbx
# x
movq -8(%rbp), %r10
# y + x
addq %r10, %rbx
movq %rbx, %rax
jmp .main_epilogue
.main_epilogue:
popq %r15
popq %r14
popq %r13
popq %r12
popq %rbx
movq %rbp, %rsp
popq %rbp
ret




return code: 95


===[good8.bminor Input]===
abs: function integer(n: integer);

digits: array [6] integer = {
	14,
	8,
	6168,
	42,
	0,
	74546
};

main:function integer () = {
	digits[4] = -468;
	i: integer = 0;
	for (; abs(digits[i]) == digits[i];) {
		print digits[i];
		i = i + 1;
		print ' ';
	}
	print '\n';

	return 0;
}

===[good8.bminor Output]===
TEST NOT PASSED - CODEGEN ERROR



return code: -11


===[good13.bminor Input]===
foo_epilogue: function integer () = {
	return 2;
}

foo: function integer ();

main: function integer () = {
	return foo() * 11;
}

main_epilogue: function integer () = {
	return foo_epilogue() + 3;
}

foo: function integer () = {
	return main_epilogue() - 1;
}

===[good13.bminor Output]===
TEST NOT PASSED - CODEGEN ERROR



return code: 1


===[good12.bminor Input]===
main: function integer () = {
	return 4 + 9 / (-2 - (-5)) + (((2 + 1) * 4) - 1) % 3 * 7 - 8;
}

===[good12.bminor Output]===
.text
.global main
main:
pushq %rbp
movq %rsp, %rbp
subq $0, %rsp
pushq %rbx
pushq %r12
pushq %r13
pushq %r14
pushq %r15
# 4
movq $4, %rbx
# 9
movq $9, %r10
# 2
movq $2, %r11
# -2
negq %r11
# 5
movq $5, %r12
# -5
negq %r12
# -2 - -5
subq %r12, %r11
# 9 / (-2 - -5)
movq %r10, %rax
cqo
idivq %r11
movq %rax, %r10
# 4 + 9 / (-2 - -5)
addq %r10, %rbx
# 2
movq $2, %r10
# 1
movq $1, %r11
# 2 + 1
addq %r11, %r10
# 4
movq $4, %r11
# (2 + 1) * 4
movq %r10, %rax
imulq %r11
movq %rax, %r10
# 1
movq $1, %r11
# (2 + 1) * 4 - 1
subq %r11, %r10
# 3
movq $3, %r11
# ((2 + 1) * 4 - 1) % 3
movq %r10, %rax
cqo
idivq %r11
movq %rdx, %r10
# 7
movq $7, %r11
# ((2 + 1) * 4 - 1) % 3 * 7
movq %r10, %rax
imulq %r11
movq %rax, %r10
# 4 + 9 / (-2 - -5) + ((2 + 1) * 4 - 1) % 3 * 7
addq %r10, %rbx
# 8
movq $8, %r10
# 4 + 9 / (-2 - -5) + ((2 + 1) * 4 - 1) % 3 * 7 - 8
subq %r10, %rbx
movq %rbx, %rax
jmp .main_epilogue
.main_epilogue:
popq %r15
popq %r14
popq %r13
popq %r12
popq %rbx
movq %rbp, %rsp
popq %rbp
ret




return code: 13


===[good15.bminor Input]===
// https://piazza.com/class/jziupd2lzpm7cy?cid=179

strdup: function string (s: string);

main: function integer () = {
	a: string = "sssss";
	b: string = strdup(a);
	if (a==b) return 22; else return 11;
}

===[good15.bminor Output]===
TEST NOT PASSED - CODEGEN ERROR



return code: 1


===[good17.bminor Input]===
a1: integer;
a2: integer = 111;
a3: boolean = false;

A: function integer() = {
	if (a3) return a1 * a2;
	a2: integer = 3;
	if (!!!a3) return a1 + a2;
	return 0;
}

main: function integer() = { return A(); }

===[good17.bminor Output]===
TEST NOT PASSED - COMPILE ERROR


../hidden-tests/codegen/good17.bminor.s: Assembler messages:
../hidden-tests/codegen/good17.bminor.s:54: Error: number of operands mismatch for `xor'
../hidden-tests/codegen/good17.bminor.s:56: Error: number of operands mismatch for `xor'
../hidden-tests/codegen/good17.bminor.s:58: Error: number of operands mismatch for `xor'

return code: 1


===[good18.bminor Input]===
b1: integer = 3;
b2: integer = 6;
b3: integer = 9;

B: function integer(b3: integer, b4: integer) = {
	print b1 * b2 + b3 % b4;
	print '\n';
	b3 = 37;
	return b3;
}

main: function integer () = {
	print B(5, 3);
	return b3;
}

===[good18.bminor Output]===
.data
.global b1
b1:
    .quad 3

.data
.global b2
b2:
    .quad 6

.data
.global b3
b3:
    .quad 9

.text
.global B
B:
pushq %rbp
movq %rsp, %rbp
subq $0, %rsp
pushq %rbx
pushq %r12
pushq %r13
pushq %r14
pushq %r15
# b3
movq  8(%rbp), %rbx
# 37
movq $37, %r10
# b3 = 37
movq %r10,  8(%rbp)
# b3
movq  8(%rbp), %rbx
movq %rbx, %rax
jmp .B_epilogue
.B_epilogue:
popq %r15
popq %r14
popq %r13
popq %r12
popq %rbx
movq %rbp, %rsp
popq %rbp
ret

.text
.global main
main:
pushq %rbp
movq %rsp, %rbp
subq $0, %rsp
pushq %rbx
pushq %r12
pushq %r13
pushq %r14
pushq %r15
# b3
movq b3, %rbx
movq %rbx, %rax
jmp .main_epilogue
.main_epilogue:
popq %r15
popq %r14
popq %r13
popq %r12
popq %rbx
movq %rbp, %rsp
popq %rbp
ret




return code: 9


===[good4.bminor Input]===
collatz: function integer(n: integer, acc: integer) = {
	print n, " ", acc, "\n";
	if (n == 1) return acc;

	if (n % 2 == 0) return collatz(n/2, acc + 1);
	else return collatz(3*n + 1, acc + 1);
}

main:function integer ()=
{
	return collatz(27, 0);
}

===[good4.bminor Output]===
TEST NOT PASSED - COMPILE ERROR


../hidden-tests/codegen/good4.bminor.s: Assembler messages:
../hidden-tests/codegen/good4.bminor.s:19: Error: bad register name `%rbxsete %al'
../hidden-tests/codegen/good4.bminor.s:46: Error: bad register name `%rbxsete %al'

return code: 1


===[good20.bminor Input]===
D: function integer() = {
	d1: integer = 5;
	d2: integer = d1 + 1; //6
	{
		d3: integer = 9;
		d2: integer = d3 + d1 - 3; //11
		d4: integer = -1;
		d2 = d2 + d3; //20
		print d2 - d4, "\n";
	}
	d4: integer = 16;
	print d2 - d4, '\n';
	{
		d4: integer = -2;
		d3: integer = 1000;
		print d3 + 10;
		print "\n";
		print d4;
		print '\n';
	}
	print d4;
	return 3;
}

main: function integer () = {
	return D();
}

===[good20.bminor Output]===
.text
.global D
D:
pushq %rbp
movq %rsp, %rbp
subq $64, %rsp
pushq %rbx
pushq %r12
pushq %r13
pushq %r14
pushq %r15
# 5
movq $5, %rbx
movq %rbx, -8(%rbp)
# d1
movq -8(%rbp), %rbx
# 1
movq $1, %r10
# d1 + 1
addq %r10, %rbx
movq %rbx, -16(%rbp)
# 9
movq $9, %rbx
movq %rbx, -24(%rbp)
# d3
movq -24(%rbp), %rbx
# d1
movq -8(%rbp), %r10
# d3 + d1
addq %r10, %rbx
# 3
movq $3, %r10
# d3 + d1 - 3
subq %r10, %rbx
movq %rbx, -32(%rbp)
# 1
movq $1, %rbx
# -1
negq %rbx
movq %rbx, -40(%rbp)
# d2
movq -32(%rbp), %rbx
# d2
movq -32(%rbp), %r10
# d3
movq -24(%rbp), %r11
# d2 + d3
addq %r11, %r10
# d2 = d2 + d3
movq %r10, -32(%rbp)
# 16
movq $16, %rbx
movq %rbx, -48(%rbp)
# 2
movq $2, %rbx
# -2
negq %rbx
movq %rbx, -56(%rbp)
# 1000
movq $1000, %rbx
movq %rbx, -64(%rbp)
# 3
movq $3, %rbx
movq %rbx, %rax
jmp .D_epilogue
.D_epilogue:
popq %r15
popq %r14
popq %r13
popq %r12
popq %rbx
movq %rbp, %rsp
popq %rbp
ret

.text
.global main
main:
pushq %rbp
movq %rsp, %rbp
subq $64, %rsp
pushq %rbx
pushq %r12
pushq %r13
pushq %r14
pushq %r15
# D
# D()
pushq %r10
pushq %r11
call D
addq $0, %rsp
pushq %r11
pushq %r10
movq %rax, %r10
movq %r10, %rax
jmp .main_epilogue
.main_epilogue:
popq %r15
popq %r14
popq %r13
popq %r12
popq %rbx
movq %rbp, %rsp
popq %rbp
ret




return code: 3


===[good3.bminor Input]===
T: array [8] integer = {2, 1, 1, 2, 1, 2, 0, 3};

main:function integer ()=
{
	i: integer = 0;
        for (;;) {
		if (T[i] == 0) return T[5] + 10;
		else if (T[i] == 1) i++;
		else if (T[i] == 2) T[i++]--;
		else return 1;
	}

	return 0;
}

===[good3.bminor Output]===
TEST NOT PASSED - CODEGEN ERROR



return code: -11


===[good5.bminor Input]===
A: function boolean(x: integer, y: integer);
B: function integer(x: char);
C: function char(a: string);

main: function integer() = {
	if (A(B('d') - 1, 10)) {
		x: integer = 3;
		return 2 * B('!') + x;
	}
	return B(C("hello")) % 3;
}

A: function boolean(x: integer, y: integer) = {
	return x == y;
}

B: function integer(c: char) = {
	if (c == '!')
		return 10;
	else {return 11;}
}

C: function char(a: string) = {
	return '!';
}

===[good5.bminor Output]===
TEST NOT PASSED - CODEGEN ERROR



return code: 3


===[good6.bminor Input]===
f: function boolean(b: boolean) = {
	return !b;
}

x: integer = -4;

main:function integer ()=
{
	y: integer = 10;
	if (f(f(f(f(f(x <= y)))))) return 1;
	else if (x < y - x*y) {
		return 4;
	} else return 2;
}

===[good6.bminor Output]===
TEST NOT PASSED - CODEGEN ERROR



return code: 20


===[good7.bminor Input]===
f: function void (i: integer) = {
	N: integer;
	for (N = 0; i > 0; i--) {
		print N;
		N = N + 1;
	}
}

main:function integer () = {
	N: integer = 6;
	for (;;N--) {
		f(N);
		print '\n';
		if (N == 0) return 0;
	}

	return 1;
}

===[good7.bminor Output]===
TEST NOT PASSED - CODEGEN ERROR



return code: -11


===[good9.bminor Input]===
a: array[4] integer;
main: function integer() = {
	a[2] = 60;
	return a[2] + a[2] / 20 * 3 - a[1];
}

===[good9.bminor Output]===
TEST NOT PASSED - CODEGEN ERROR



return code: -11


===[good2.bminor Input]===


X: array [4] integer = {11, 30, 22, 0};

main: function integer () = {
	i: integer;
	for (i = 0; X[i] != 0; i++)
		print X[i], ' ', X[i] % 3, '\n';

	return 0;
}

===[good2.bminor Output]===
TEST NOT PASSED - COMPILE ERROR


../hidden-tests/codegen/good2.bminor.s: Assembler messages:
../hidden-tests/codegen/good2.bminor.s:39: Error: bad register name `%r12setne %al'
../hidden-tests/codegen/good2.bminor.s:41: Error: number of operands mismatch for `cmp'
../hidden-tests/codegen/good2.bminor.s:49: Error: junk `:' after expression

return code: 1


===[good19.bminor Input]===
c1: integer = -1;
c3: integer = 100;

d1: integer = 1;
d2: integer = 2;

C: function integer(c1: integer, c2: integer) = {
	c3: integer = 11;
	c4: integer = 12;
	c5: integer = 13;
	return c1 + c2 + c3 + c4;
}

D: function integer(d1: integer, d2: integer) = {
	d3: integer = -3;
	d4: integer = 4;
	d5: integer = 5;
	return d1 + d2 + d3 - d4;
}

main: function integer() = {
	f: integer = D(6, 7);
	return C(1, 2);
}

===[good19.bminor Output]===
.data
.global c1
c1:
    .quad -

.data
.global c3
c3:
    .quad 100

.data
.global d1
d1:
    .quad 1

.data
.global d2
d2:
    .quad 2

.text
.global C
C:
pushq %rbp
movq %rsp, %rbp
subq $24, %rsp
pushq %rbx
pushq %r12
pushq %r13
pushq %r14
pushq %r15
# 11
movq $11, %rbx
movq %rbx, -8(%rbp)
# 12
movq $12, %rbx
movq %rbx, -16(%rbp)
# 13
movq $13, %rbx
movq %rbx, -24(%rbp)
# c1
movq  8(%rbp), %rbx
# c2
movq  16(%rbp), %r10
# c1 + c2
addq %r10, %rbx
# c3
movq -8(%rbp), %r10
# c1 + c2 + c3
addq %r10, %rbx
# c4
movq -16(%rbp), %r10
# c1 + c2 + c3 + c4
addq %r10, %rbx
movq %rbx, %rax
jmp .C_epilogue
.C_epilogue:
popq %r15
popq %r14
popq %r13
popq %r12
popq %rbx
movq %rbp, %rsp
popq %rbp
ret

.text
.global D
D:
pushq %rbp
movq %rsp, %rbp
subq $48, %rsp
pushq %rbx
pushq %r12
pushq %r13
pushq %r14
pushq %r15
# 3
movq $3, %rbx
# -3
negq %rbx
movq %rbx, -32(%rbp)
# 4
movq $4, %rbx
movq %rbx, -40(%rbp)
# 5
movq $5, %rbx
movq %rbx, -48(%rbp)
# d1
movq  8(%rbp), %rbx
# d2
movq  16(%rbp), %r10
# d1 + d2
addq %r10, %rbx
# d3
movq -32(%rbp), %r10
# d1 + d2 + d3
addq %r10, %rbx
# d4
movq -40(%rbp), %r10
# d1 + d2 + d3 - d4
subq %r10, %rbx
movq %rbx, %rax
jmp .D_epilogue
.D_epilogue:
popq %r15
popq %r14
popq %r13
popq %r12
popq %rbx
movq %rbp, %rsp
popq %rbp
ret

.text
.global main
main:
pushq %rbp
movq %rsp, %rbp
subq $56, %rsp
pushq %rbx
pushq %r12
pushq %r13
pushq %r14
pushq %r15
# D
# D(6, 7)
pushq %r10
pushq %r11
# 6
movq $6, %r11
# 7
movq $7, %r12
# 7
pushq %r12
# 6, 7
pushq %r11
call D
addq $16, %rsp
pushq %r11
pushq %r10
movq %rax, %r10
movq %r10, -56(%rbp)
# C
# C(1, 2)
pushq %r10
pushq %r11
# 1
movq $1, %r12
# 2
movq $2, %r13
# 2
pushq %r13
# 1, 2
pushq %r12
call C
addq $16, %rsp
pushq %r11
pushq %r10
movq %rax, %r11
movq %r11, %rax
jmp .main_epilogue
.main_epilogue:
popq %r15
popq %r14
popq %r13
popq %r12
popq %rbx
movq %rbp, %rsp
popq %rbp
ret




return code: 19


===[good10.bminor Input]===
w: string = "no";

f: function void (s: string) = {
	{
		w: string = "ok";
		print w, "\n";
		w = "bad!\n";
	}
	print s, ' ', w;
	print " ";
	s = "changed\n";
	print s;
}

main:function integer ()= {
	s: string = "good";
	f(s);
	print s;

	return 0;
}

===[good10.bminor Output]===
TEST NOT PASSED - COMPILE ERROR


../hidden-tests/codegen/good10.bminor.s: Assembler messages:
../hidden-tests/codegen/good10.bminor.s:22: Error: bad register name `%rbxmovq %rbx'
../hidden-tests/codegen/good10.bminor.s:28: Warning: unterminated string; newline inserted
../hidden-tests/codegen/good10.bminor.s:38: Warning: unterminated string; newline inserted
../hidden-tests/codegen/good10.bminor.s:69: Error: bad register name `%rbxmovq %rbx'

return code: 1


===[good14.bminor Input]===
/*
Return pointer to (constant) global
string which is valid to display.
*/

s: string = "ok\n";

f: function string() = {
	t: string = s;
	return t;
}

main: function integer () = {
	print f();
	return 0;
}

===[good14.bminor Output]===
.data
.global s
s:
    .string "ok\n"

.text
.global f
f:
pushq %rbp
movq %rsp, %rbp
subq $8, %rsp
pushq %rbx
pushq %r12
pushq %r13
pushq %r14
pushq %r15
# s
leaq s, %rbx
movq %rbx, -8(%rbp)
# t
leaq -8(%rbp), %rbx
movq %rbx, %rax
jmp .f_epilogue
.f_epilogue:
popq %r15
popq %r14
popq %r13
popq %r12
popq %rbx
movq %rbp, %rsp
popq %rbp
ret

.text
.global main
main:
pushq %rbp
movq %rsp, %rbp
subq $8, %rsp
pushq %rbx
pushq %r12
pushq %r13
pushq %r14
pushq %r15
# 0
movq $0, %rbx
movq %rbx, %rax
jmp .main_epilogue
.main_epilogue:
popq %r15
popq %r14
popq %r13
popq %r12
popq %rbx
movq %rbp, %rsp
popq %rbp
ret




return code: 0


===[good16.bminor Input]===
// https://piazza.com/class/jziupd2lzpm7cy?cid=176

main: function integer() = {
	print "Testing printing literals", '\n', 123, "abc", true, false, 5;
	return 0;
}


===[good16.bminor Output]===
.text
.global main
main:
pushq %rbp
movq %rsp, %rbp
subq $0, %rsp
pushq %rbx
pushq %r12
pushq %r13
pushq %r14
pushq %r15
# 0
movq $0, %rbx
movq %rbx, %rax
jmp .main_epilogue
.main_epilogue:
popq %r15
popq %r14
popq %r13
popq %r12
popq %rbx
movq %rbp, %rsp
popq %rbp
ret




return code: 0


====Bad Tests====
===== SUMMARIZED CODEGEN RESULTS =====
{
  "student_tests": {
    "Good": {
      "correct": 20,
      "incorrect": 0
    },
    "Bad": {
      "correct": 0,
      "incorrect": 0
    }
  },
  "hidden_tests": {
    "Good": {
      "correct": 7,
      "incorrect": 13
    },
    "Bad": {
      "correct": 0,
      "incorrect": 0
    }
  }
}

Codegen Project Grade
-------------------

General Structure: 15/25
---------------------------------
Improper argument format as required for bminor program. 
Should take a second argument as a filename for the output file.

Some issues with codegen and parsing 

Codegen - Functionality 15/15 
--------------------------------------------
Code that did compile seems to function

Codegen - Assembly Structure 9/10 
--------------------------------------------
One syntax error in assembly

Student Tests: 20/20
---------------------------
Passes all your tests.

Hidden Tests: 7/20
---------------------------
Passes 7 hidden tests

Code Style: 10/10
------------------------
Looks good.

Extra Credit: 0/10
------------------------

Total: 76/100
------------------------------------------
